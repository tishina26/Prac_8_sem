# -*- coding: utf-8 -*-
"""Копия блокнота "Копия блокнота "Метод Франк-Вульфа.ipynb""

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ipPjt774wyFDDwkX_FoLLuGai9HgSDkn
"""

import numpy as np
from scipy.optimize import linprog
from scipy.optimize import minimize
import pandas as pd

"""# my functions"""

def my_grad(f, x, h=1e-6):
  grad = np.zeros_like(x)
  for i in range(len(x)):
    x_plus_h = x.copy()
    x_plus_h[i] += h
    # grad[i] = (f(x_plus_h) - f(x)) / h
    grad[i] = (f([(x[j] if j!=i else x[j] + h) for j in range(len(x))]) - f(x)) / h

  return grad

def norm(arr):
    return sum(i**2 for i in arr)**0.5

def find_xk(f, a,b, tol=1e-6, max_iter = 100):
    hk = 2 - (1 + 5**0.5) / 2

    x1 = a + hk * (b - a)        # начальные точки
    x2 = b - hk * (b - a)
    # print(x1,x2)
    f1 = f(x1)
    f2 = f(x2)
    # print(f1,f2)

    for _ in range(max_iter):
        # print(x1,x2)
        if norm(b - a) < tol:
            break
        # print("f1f2",f1,f2)
        if f1 < f2:
            b, x2, f2 = x2, x1, f1
            x1 = a + hk * (b - a)
            f1 = f(x1)
        else:
            a, x1, f1 = x1, x2, f2
            x2 = b - hk * (b - a)
            f2 = f(x2)

    return (a + b) / 2

"""# Frank-Wolf"""

def frank_wolf(fi, x0, A, b, A_eq, b_eq, max_iter, eps, view=0):
   xk = x0
   k = 0
   opt = {'k': 0,
          'x': x0,
          'f': 0,
          'status': -1}

   while (k <= max_iter):
      df = my_grad(fi, xk)
      if view: print(f'grad(x{k}) = {df}')

      # minimize
      if A is None:
          res = linprog(df, A_eq=A_eq, b_eq=b_eq)
      else:
          res = linprog(df, A_ub=-A, b_ub=-b, A_eq=A_eq, b_eq=b_eq)
      yk = res.x
      if yk is None:
          opt['status'] = -1
          if view: print("yk is None: ", res)
          return opt
      if res.status != 0:
          opt['status'] = -1
          if view: print("status of linprog is not 0: ", res)
          return opt
      if view: print(f'y{k} = {yk}')

      # alpha search for xk+1 = xk + ak(yk-xk) for 0<=ak<=1
      prev = xk
      xk = find_xk(fi,xk,yk)
      if view: print(f'x{k} = {xk}')

      # fill opt
      opt['k'] = k
      opt['f'] = fi(xk)
      opt['x'] = xk
      k += 1
      # break
      if (norm(xk - prev) < eps) and (abs(fi(xk) - fi(prev)) < eps):
          opt['status'] = 0
          break
   return opt

"""# example

f(x) -> min

A * x >= b

A_eq * x = b_eq
"""

res_fw = []
res_min = []

"""## ex1"""

def f(x):
    return x[0]**0.25 + (x[1]/x[0])**0.25 + (64/x[1])**0.25
x0 = np.array([2,10])
A = np.array([[1, 0],
              [-1, 1],
              [0, -1]])
b = np.array([1, 0, -64])
A_eq, b_eq = None, None
max_iter = 100
eps = 0.001
opt = frank_wolf(f, x0, A, b, A_eq, b_eq, max_iter, eps, 1)
# opt
res = minimize(
    f,
    x0,
    constraints = {"type": "ineq", "fun": lambda x: A @ x - b},
    options={"maxiter": max_iter}, # Дополнительные параметры
)
# print(res)

res_fw.append(opt)
res_min.append(res)

"""## ex2"""

def f2(x):
    return (x[0]-1)**2 + 2*(x[1]-1)**2 - 3
x0 = np.array([0,0])
A = np.array([[-1, -2],
              [-2, 1],
              [0, 1],
              [1, 0]])
b = np.array([-8, -12, 0, 0])
A_eq, b_eq = None, None
max_iter = 100
eps = 0.001
opt = frank_wolf(f2, x0, A, b, A_eq, b_eq, max_iter, eps, 1)
print(opt)
res = minimize(
    f2,
    x0,
    constraints = {"type": "ineq", "fun": lambda x: A @ x - b},
    options={"maxiter": max_iter}, # Дополнительные параметры
)
# print(res)

res_fw.append(opt)
res_min.append(res)

"""## ex3"""

def f2(x):
    return -(-x[0]**2 + x[0]*x[1] - 2 * x[1]**2 + 4*x[0]+6*x[1])
x0 = np.array([3,1])
A = np.array([[-1, -1],
              [1, 2],
              [0, 1],
              [1, 0]])
b = np.array([-4, 2, 0, 0])
A_eq, b_eq = None, None
max_iter = 1000
eps = 0.0001
opt = frank_wolf(f2, x0, A, b, A_eq, b_eq, max_iter, eps, 1)
print(opt)
res = minimize(
    f2,
    x0,
    constraints = {"type": "ineq", "fun": lambda x: A @ x - b},
    options={"maxiter": max_iter}, # Дополнительные параметры
)
# print(res)

res_fw.append(opt)
res_min.append(res)

"""##ex4"""

def f2(x):
    return np.sin(x[0]) + np.cos(x[1]**2)
x0 = np.array([0.1,0.1])
A = np.array([[-1, -1],
              [0,1],
              [1,0],
              [2,5]])
b = np.array([-4,0,0,1])
A_eq, b_eq = None, None
max_iter = 1000
eps = 0.0001
opt = frank_wolf(f2, x0, A, b, A_eq, b_eq, max_iter, eps, 1)
print(opt)
res = minimize(
    f2,
    x0,
    constraints = {"type": "ineq", "fun": lambda x: A @ x - b},
    options={"maxiter": max_iter}, # Дополнительные параметры
)
# print(res)

res_fw.append(opt)
res_min.append(res)

"""# result table

##fun
"""

def round_arr(arr, r=3):
    t = 10**r
    arr2 = []
    for i in range(len(arr)):
        arr2.append(int(arr[i]*t)/t)
    return arr2

def compare_results_df(res_fw, res_min, eps=1e-3, r=4):
    for i in range(len(res_fw)):
        fw = res_fw[i]
        mn = res_min[i]

        fun_comparison = abs(fw['f'] - mn.fun) < eps

        status_comparison = 0 if ((fw['status'] == mn.status) == 0) else -1

        x_comparison = "-"

        if fw['k'] == mn.nit:
            nit_comparison = "равны"
        elif fw['k'] > mn.nit:
            nit_comparison = "Ф-В хуже"
        else:
            nit_comparison = "Ф-В лучше"

        data = {
            "Метод Франка-Вульфа": [fw['f'], fw['status'], round_arr(fw['x']), fw['k']],
            "Минимизация": [mn.fun, mn.status, round_arr(mn.x), mn.nit],
            "Сравнение": [fun_comparison, status_comparison, x_comparison, nit_comparison]
        }

        df = pd.DataFrame(data, index=["F", "статус", "x", "Кол-во итераций"])

        print(f"\nПример {i+1}:")
        print(df)

"""##see"""

compare_results_df(res_fw, res_min)