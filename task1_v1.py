# -*- coding: utf-8 -*-
"""Копия блокнота "Метод Франк-Вульфа.ipynb"

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ly-pzohGE4x5uBl-e5yovdr2dgSvSKMZ
"""

import numpy as np
from scipy.optimize import linprog

"""# function

Нелинейная функция на минимум
"""

def f(x):
  return x[0]**0.25 + (x[1]/x[0])**0.25 + (64/x[1])**0.25

"""# my functions"""

def my_grad(f, x, h=1e-6):
  grad = np.zeros_like(x)
  for i in range(len(x)):
    x_plus_h = np.copy(x)
    x_plus_h[i] += h
    grad[i] = (f(x_plus_h) - f(x)) / h
  return grad

def norm(arr):
    return sum(i**2 for i in arr)**0.5

def find_xk(f, a,b, tol=1e-6, max_iter = 100):
    hk = 2 - (1 + 5**0.5) / 2

    x1 = a + hk * (b - a)        # начальные точки
    x2 = b - hk * (b - a)
    # print(x1,x2)
    f1 = f(x1)
    f2 = f(x2)
    # print(f1,f2)

    for _ in range(max_iter):
        # print(x1,x2)
        if norm(b - a) < tol:
            break
        # print("f1f2",f1,f2)
        if f1 < f2:
            b, x2, f2 = x2, x1, f1
            x1 = a + hk * (b - a)
            f1 = f(x1)
        else:
            a, x1, f1 = x1, x2, f2
            x2 = b - hk * (b - a)
            f2 = f(x2)

    return (a + b) / 2

"""# Frank-Wolf"""

def frank_wolf(f, x0, A, b, A_eq, b_eq, max_iter, eps, view=0):
   xk = x0
   k = 0
   opt = {'k': 0,
          'x': x0,
          'f': f,
          'status': -1}

   while (k <= max_iter):
      df = my_grad(f, xk)
      if view: print(f'grad(x{k}) = {df}')

      # minimize
      res = linprog(df, A_ub=-A, b_ub=-b, A_eq=A_eq, b_eq=b_eq)
      yk = res.x
      if view: print(f'y{k} = {yk}')

      # alpha search for xk+1 = xk + ak(yk-xk) for 0<=ak<=1
      prev = xk
      xk = find_xk(f,xk,yk)
      if view: print(f'x{k} = {xk}')

      # fill opt
      opt['k'] = k
      opt['f'] = f(xk)
      opt['x'] = xk
      k += 1
      # break
      if (norm(xk - prev) < eps) and (abs(f(xk) - f(prev)) < eps):
          opt['status'] = 0
          break
   return opt

"""# example"""

x0 = np.array([2,10])

"""f(x) -> min

A * x >= b

A_eq * x = b_eq
"""

A = np.array([[1, 0],
              [-1, 1],
              [0, -1]])
b = np.array([1, 0, -64])
A_eq, b_eq = None, None

max_iter = 100
eps = 0.001
frank_wolf(f, x0, A, b, A_eq, b_eq, max_iter, eps, 0)

